# Intro to Formal Languages. Regular Grammars. Finite Automata

### Course: Formal Languages & Finite Automata

### Author: Rustem Cimendur

---

## Theory

A formal language represents a well-defined system for constructing valid strings from a finite alphabet according to a set of grammatical rules.
Any formal language is described through terminal symbols, non-terminal symbols, production rules, and a start symbol.
In the case of **regular grammars**, productions are restricted to right-linear forms, meaning that each rule produces either a terminal followed by a non-terminal or a terminal alone.

This restriction is important because regular grammars are **equivalent in expressive power to finite automata**.
Therefore, every language generated by a regular grammar can also be recognized by a finite automaton constructed from the same rules.
The laboratory work demonstrates this theoretical equivalence through a practical software implementation.

---

## Objectives

The purpose of this laboratory work is to model a regular grammar in code, generate valid strings of the language, transform the grammar into a finite automaton, and verify string membership using the constructed automaton.

---

## Implementation description

The solution is implemented in Python using two main abstractions: **Grammar** and **FiniteAutomaton**.
The `Grammar` class stores non-terminal symbols, terminal symbols, production rules, and the start symbol.
It also provides functionality for generating valid strings and converting the grammar into a finite automaton.

The `FiniteAutomaton` class models a nondeterministic finite automaton using a set of states, an input alphabet, a transition function, a start state, and a set of final states.
A dedicated method simulates the automaton step-by-step to determine whether an input string belongs to the language.

### Grammar construction

The grammar used in this laboratory corresponds to **Variant 6**.
It is defined programmatically by explicitly specifying symbol sets and production rules:

```python
grammar = Grammar(
    non_terminal_symbols={"S", "I", "J", "K"},
    terminal_symbols={"a", "b", "c", "e", "n", "f", "m"},
    start_symbol="S",
    production_rules={
        "S": ["cI"],
        "I": ["bJ", "fI", "eK", "e"],
        "J": ["nJ", "cS"],
        "K": ["nK", "m"],
    },
)
```

Each production string is interpreted as a **sequence of terminals optionally followed by a final non-terminal**.
For example, the rule `"cI"` means that terminal `c` is produced and the derivation continues from non-terminal `I`, while the rule `"e"` produces a terminal and terminates the derivation.

### String generation

Valid strings are produced by repeatedly selecting random production rules starting from the start symbol.
The process continues until a rule without a following non-terminal is reached, which finalizes the generated word.

```python
generated_strings = [grammar.generateString() for _ in range(5)]
```

This demonstrates that the implemented grammar is capable of **constructing words that belong to the defined language**.

### Grammar to finite automaton conversion

The conversion procedure follows the classical construction:

* every non-terminal becomes a state of the automaton
* a rule of the form **A → xB** creates a transition labeled `x` from state `A` to state `B`
* a rule of the form **A → x** creates a transition from `A` to a dedicated final state

If multiple terminals appear in sequence, intermediate helper states are automatically inserted to preserve the **one-symbol transition requirement** of finite automata.

### String membership verification

After building the automaton, each generated string is validated by simulating nondeterministic transitions across states:

```python
result = automaton.stringBelongToLanguage(generated)
```

If at least one computation path ends in a final state after consuming the entire input, the string is accepted.

---

## Conclusions / Results

In this laboratory work, a practical implementation of a regular grammar and its equivalent finite automaton was developed.
The grammar successfully generated valid strings according to the defined production rules, confirming the correctness of the derivation process.

A systematic transformation from the grammar to a nondeterministic finite automaton (NFA) was constructed by mapping productions to state transitions and introducing helper states when necessary.
The automaton correctly verified membership for the generated strings, demonstrating the equivalence between regular grammars and finite automata.

Overall, the work illustrates how formal language theory can be translated into a concrete computational model for string generation and validation.

---

## References

Course materials for *Formal Languages & Finite Automata*.
Hopcroft, Motwani, Ullman — *Introduction to Automata Theory, Languages, and Computation*.
